1) 메인함수에 모든 내용을 작성할 수 있음에도 불구하고, 굳이 왜 나눠서 쓰나요?
- 너무 길어져서, 가독성이 떨어지고, 유지보수가 힘들어진다 (단일 책임 원칙)

2) 1번에 따라서, 각 기능이 클래스별로 분리되면 서로 다른 객체가 연계하여 프로그램을 진행해야 한다
객체간의 참조를 위해서, 이전에는 <c:set>, DAO.getInstance() 등을 직접 작성했다면
스프링에서는 스프링 컨테이너 안에 담긴 스프링 빈 끼리의 의존성을 자동으로 설정할 수도 있다

3) 외부 라이브러리 클래스는 <bean> 태그를 이용하여 생성해주는것이 보통이고
직접 작성하는 클래스는 어노테이션을 활용하여 스프링 빈으로 등록한다
단, <context:component-scan>태그를 이용하여 스캔할 패키지를 지정해주어야 한다

4) a객체가 b객체를 참조하기 위해서는 A클래스에 B타입의 멤버필드가 만들어져 있어야 한다
(a테이블이 b테이블을 참조하려면, 외래키가 필요하다)

@Component
class A {
    // 여자친구 b = new 여자친구();
    // 여자친구 b = 여자친구.getInstance();

    @Autowired 여자친구 b;
}

@Component
class 여자친구 {
    int age;
}

	A a = new A();
  	System.out.println(a.b.age);	

5) 스프링 MVC 에서는 어떤 컴포넌트들이 어떤 역할을 수행합니까?
- @Controller : 요청을 받아서 처리하는 함수를 가진다. 주로 JSP에 포워드하거나, 다른 주소로 redirect한다
	       컨트롤러는 보통 서비스를 참조한다

- @Service : 컨트롤러가 처리하는 내용의 상세하고 구체적인 내용을 작성할 수 있다
	    주로, 요청/응답 및 SQL과 상관없는 자바 중립적인 코드를 작성한다
	    컨트롤러와 DAO사이의 연결 및 중립지대를 형성하는 역할도 한다
	    서비스는 보통 DAO를 참조한다 

- @Repository : 데이터 저장소를 의미하며, DAO 클래스에 부여하는 어노테이션
	       내부에서 발생하는 예외를 DataAccessException 으로 바꿔서 throw 한다
	       DAO는 sqlSessionTemplate을 참조한다(마이바티스 사용시)
	       단, 매퍼 자동 주입을 사용하면 필드를 참조하지 않아도 된다

